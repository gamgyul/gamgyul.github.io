---
layout: page
title: NewSQL에서 뭐가 New일까? 
category : CS
---
NewSQL가 RDBMS와 NoSQL의 장점만을 합친 DB라고해서 어떻게 그게 가능한건지 궁금증이 생겼다. NewSQL 문서를 검색하니 [링크](https://db.cs.cmu.edu/papers/2016/pavlo-newsql-sigmodrec2016.pdf)의 문서가 나와서 해당 문서를 번역하면서 정리한것을 적어보려고한다.

## DBMS의 역사

* 1960년대 : DBMS의 시작
* 1970~80년대 : RDBMS의 등장(Oracle, INGRES, Sybase, DB2 ...)
* 1980~90년대
    * 객체지향 DBMS등장
        - 업적으로 잘되지 않았지만 RDBMS에 아이디어 들이 차용
        - 20년후에는 Document oriented NoSQL에서 사용
    * OpenSource DB들이 등장
        * MySQL
        * PostgreSQL
* 2000년대
    * 인터넷의 발달로 데이터베이스에 처리 요구량이 많아짐
        - Scale up하기에는 코스트가 많이들고 장비를 옮기는동안 서비스가 다운됨.
        - 일부 기업에서는 클러스터를 만들고 쿼리 실행을 분할시켜주는 미들웨어를 개발함.
            * select나 single record update에는 유용하지만 transaction이나 join에는 지원이 어렵다는 단점이있음.
        - 미들웨어로는 한계가 있어 일부 기업들은 자체DB를 개발을 함.
            * 기존 DBMS는 동시성과 정확성이 우선이였지만 web에서는 그보다 동시에 많은 app을 지원하는게 우선이였음.
            * 간단한 데이터를 저장하는데에 RDBMS를 사용하기에는 오버헤드가 큼
            * relational model과 SQL역시 단순조회에 지나침
        - NoSQL의 등장
            * transaction과 관계형 모델을 포기하고 최종일관성과 다른 데이터 모델을 사용
                * Document
                * graph
                * key/value
            * NoSQL DB들
                * Google BigTable
                * Amazon Dynamo
                * FaceBook Cassandra
                * PowerSet HBase
                * MongoDB etc..

NoSQL을 사용하는 장점에는 개발자가 DB scaleout에 대해서 걱정없이 비지니스 로직에 집중을 할 수 있다는것이다. 하지만 많은곳에서는 아직도 강력한 transaction 기능이 필요한 곳이 많고 inconsistent 데이터를 처리하는데 어려움이 있어서 NewSQL이 탄생하게 되었다.


<!-- DBMS는 1960년대에 등장했고 그중 하나로 IBM에서 만든 IMS가 아폴로 프로젝트에 사용되었는데 이는 개발자들이 개발을 할때 데이터에 관해서 데이터를 엑세스하거나 조작하는데에만 신경써도 되게 만들어줬다.

이후 1970~1980년대에 INGRES, Oracle, Sybase, DB2등의 관계대수를 바탕으로한 RDBMS가 탄생했다.1980~1990년에서는 객체지향 프로그래밍에 맞춰 객체 지향 DBMS들이 나왔는데 인기를 얻지 못했지만 RDBMS에서 아이디어들이 차용되었고 20년 지나서는 document oriented NoSQL에서 사용이 되었다.(Oracle의 Object타입같은것을 말하는것으로 보인다).
또 이시기에는 MySQL과 PostSQL이라는 오픈소스 프로젝트가 시작됬었다.

2000년대 들어서는 인터넷 어플리케이션들이 많은 사용자들에 대해서 동시에 지원하는것이 필요해졌고 그중에서 데이터베이스가 처리할수 있는 한계에 달해서 bottleneck이 되곤했다.
이를 해결하기위해서 더 좋은장비로 옮기는 scale up을 할 수 있지만 얻는 이득에 비해 코스트 소모가 크고 장비를 변경하는건 큰작업이여서 서비스가 다운이되는 시간이 오래걸리는 단점이있다.그래서 일부 기업들에서는 여러 노드들이 있는 클러스터를 만들어서 싱글 DB노드들을 분할하는 미들웨어를 만들었다. 어플리케이션이 데이터베이스에 쿼리를하면 미들웨어가 쿼리를 리다이렉션후 클러스터에서 일부노드에 실행하도록 분산 노드는 실행한 결과를 클러스터로 주고 클러스터가 어플리케이션에 결과전달을 하는방식이다.

샤딩 미들웨어를 이용하는것은 select나 single record update를 하는것에는 유용했다. 하지만 테이블 조인을 한다던가 transaction을 사용한다는가에 대해서는 어려운작업이였다.

그래서 회사들은 미들웨어를 쓰기보다 직접 DB를 개발하기로 하는데 그 동기는 크게 3가지였다.
먼저 기존의 DB는 동시성과 정확성이 우선이 였는데 이게 가용성과 성능과의 trade-off가 있었다. 그리고 이게 web 어플리케이션에서는 항상 서버에 연결이 되는것이 중요하고 여러 접속을 동시에 처리하는게 중요한데 기존rdbms는 이에 적절치 못했다.
또 단순한 값들을 저장하는데 RDBMS가 overhead라고 생각되었다. 마찬가지로 관계형 모델및 SQL자체가 어플리케이션 데이터를 처리하는데 적절치 못하다고 생각되었다.

이런문제들이 NoSQL이 생겨난 원동력이였다. NoSQL은 RDBMS의 강력한 트랜잭션 보장과 관계형 모델을 포기하고 eventual consistency(최종 일관성)과 다른 데이터 모델을 태했다.(key/value, graph, document) 왜냐면 기존 DBMS의 특징이 scale out과 availability에 방해된다고 생각을 했기 때문이다. 이러한 관점으로 생겨난 DB가 처음에는 (Google BigTable, AMZ Dynamo) 처음에 이 둘이 자체 회사내에서만 사용을해서 다른 곳에서는 다른 프로젝트로 만들어야됬는데 FaceBook Cassandra PowerSet HBase가 있고 소규모회사에서도 자체적으로 만들었는데 가장유명한게 MongoDB다.

2000년대 말에 보면 다양한 분산확장 가능한 DB가 등장하였다.
NoSQL을 사용하는 장점에는 개발자가 DB scaleout에 대해서 걱정없이 비지니스 로직에 집중을 할 수 있다는것이다. 하지만 많은곳에서는 아직도 강력한 transaction 기능이 필요한 곳이 많다.



 -->
## NewSQL이란

NewSQL은 NoSQL의 Scability를 제공하고 RDBMS모델의 트랜잭션을 제공

### NewSQL의 타겟

1. 수명이 짧은 쿼리
2. 인덱스 조회를 사용해서 small subset에 접근(즉 full scan이나 대규모 분산 조인이 없음)
3. 반복적인 읽기 쓰기 (다른 인풋으로 같은 쿼리 수행)

### NewSQL의 조건

추가적으로 문서의 필자는 NewSQL에 대한 조건을 더 좁게 정의하고있다.
1. lockfree 동시성 제어
2. shared nothing 분산 아키텍처


<!-- NewSQL은 NoSQL의 Scalability를 제공하는과 동시에 RDBMS 모델의 트랜잭션을 제공하는 DBMS이다. 따라서 NewSQL은 여러 어플리케이션의 동시 트랜잭션을 통한 데이터 수집과 데이터베이스 상태 변경을 할수있으며 개발자는 NoSQL처럼 eventually consistense(최종 일관성)처리를 위한 로직을 구현하지 않아도됩니다. 아래에서의 논의하겠지만 이 해석은 학문적 상업적시스템을 포함합니다.

위 기준에 일부사람들은 2000년대 중반에 나온 데이터웨어하우스 DBMS가 충족한다고 생각합니다. 이러한 DBMS는 OLAP 워크로드를 대상으로 해서  NEWSQL이 아닙니다.
NewSQL의 타겟은 (1) 수명이 짧은 쿼리(사용자에 의한 정지가 아님 (no user stall)이라고 표현하는데 해석이 잘안됨,) (2)인덱스 조회를 사용해서 small subset에 접근(즉 full scan 과 대규모 분산조인이 없음) (3) 반복하는 읽기쓰기 트랜잭션(다른 인풋으로 같은 쿼리 수행)입니다.
필자는 NewSQL의 조건으로  lockfree 동시성제어와 shared nothing 아키텍처로 추가적라는 더 좁은 정의에 동의하고있다. -->

### NewSQL의 분류
1. 새로운 아키텍처로 구축한 새로운 시스템
2. 구글등이 2000년대에 개발한 샤딩 인프라를 재구축한 미들웨어
3. 새로운 아키텍처 기반의 클라우드 공급업체의 DBaaS

기존 RDBMS의 분산 스토리지 엔진은 NewSQL으로 분류할 수 없다고 생각함.
<!-- 4. 그외 기존 single dbms의 새로운 엔진
    * MySQL : TokuDB, ScaleDB,  Akiban, DeepSQL
    * MSSQL : Hekaton OLTP engine 
    * PostgreSQL : , Vitesse, CitusDB -->

<!-- 

위에서 말한 조건을 가지고 NewSQL DBMS의 환경을 알아보자. NewSQL의 시스템을 나눈 3가지 분류는 우리는 이렇게 생각한다. 1)새로운 아키텍처루 구축한 새로운 시스템 2)구글등이 2000년대 에 개발한 샤딩 미들웨어를 재구성한 미들웨어 3) 새로운 아키텍처를 기반으로한 클라우드 공급업체의 DBBass.
single NODE RDBMS의 분산 스토리지 엔진은 NewSQL의 분류라고할수 없음. OLAP 기반데이터에서 column base storage engine을 쓰는게 의미가 있다고 생각하지만 일반적으로 OLTP 워크로드를 위해서는 스토리지 엔진 교체를 하는 의미가 없다고 생각한다.
 -->

#### 1. 새로운 아키텍처

* shared nothing resource
* 다음의 요소를 포함
    * 다중노드 동시성 제어
    * replication을 통한 장애 허용
    * flow control
    * 분산 쿼리 수행
* 자체 스토리지 엔진이 있음
    * HDFS와 비교했을때 쿼리로 데이터를 가져오는것이 아니라 데이터 노드로 쿼리를 보내기 때문에 네트워크 트래픽이 적음(쿼리가 데이터 보다 작음)
    * 자체 엔진이기에 replication이 보다 정교함.
* 관리 툴이나 리포팅 툴등이 부족함.

<!-- 

이 문단에서는 처음부터 새로 구성된 NewSQL을 소개한다. 분산 실행을 위한 dbms를 사용하면 모든 시스템이 다중 노드 환경에 최적화 된다는 장점이있따. 여기에는 쿼리 최적화나 노드간  통신 프로토콜등이 포함된다. 예를들어 대부분의 newsql은 미들웨어를 통한 중앙을 포함하지 않고 노드간 쿼리전송이 가능하다. 
구글 Spanner를 제외하고는 이 카테코리의 모든 DBMS가 자체적으로 in memory던 disk이던 자기만의 storage가 존재한다. 즉 HDFS에 의존하는대신 커스텀 엔진을 사용해서 리소스 전체에 데이터베이스를 배포해야한다. 이건 데이터를 쿼리로 가져오는게 아니라 쿼리를 각 데이터가 있는곳으로 보낼 수 있기때문에 네트워크 트래픽이 상당히 적다. (데이터를 보내는것보다 쿼리를 보내는것이 더 작기 떄문에). 또 자체 엔진을 쓰기때문에 HDFS에서 쓰는 블록 베이스 replication보다 정교하게 스토리지를 관리할 수 있다.  -->

#### 2. 샤딩 미들웨어

* 미들웨어를 통해서 싱글 노드 DBMS클러스터를 샤딩
* 미들웨어가 쿼리 라우팅, 노드 전체의 데이터 배치 replication과 파티션을 관리함.
* 각 노드에 미들웨어와 통신을 하는 레이어가 있어 직접 쿼리를 수행하고 미들웨어로 결과를 반환함.

장점
*  기존 싱글노드를 사용하는 어플리케이션에 적용이 쉬움.
    * ex MySQL

#### 3. DBaaS

* DBaas 제공업체에서 replication, 백업등 물리적설정까지 관리

* DBaaS중 MySQL과 같은 single node기반 DBMS를 쓰는것도 있지만 NewSQL의 새로운 아키텍처 만을 말함.
    * ex) Amazon Aurora

### 최신기술 

#### 1. 메인 메모리 저장소

* ex) 
    * MemSQL
    * SAP HANA
    * VoltDB

* disk 기반 DBMS와 다르게 디스크에 랜덤 억세스를 할 필요가 없어 버퍼 풀 관리자와 같은기능이 필요하지 안흠.
* disk 기반 DBMS보다 성능이 뛰어남

* 메모리보다 큰 사이즈를 사용하기 위한 방법
    1. 시스템 내부 추적 메카니즘을 이용해서 더이상 엑세스 되지 않는 튜플을 디스크로 제거하는 방식
    2. OS 가상 메모리 페이징을 이용.
    3. 메모리에 추적 데이터를 넣지 않는 대신 로그 구조화된 스토리지에 저장



<!-- 1970년대의 DBMS는 모두 disk기반 DBMS였다. 이떄 db의 우선 저장장치는 SSD, HDD같은 block address 영구적 장치였다. disk에 r/w하는것은 느리기때문에 메모리를 cache로 사용했고 transaction의 업데이트를 버터링했다. 이건 당연했던게 메모리는 디스크보다 작고 비쌌기때문이다. 이제는 메모리가 가장큰 OLTP 데이터베이스를 제외하고는 가격이나 용량이 합리적이게됬다. 이러한 구조에서는 dbms의 트랜잭션 데이터가 디스크에 있다고 가정하지 않아도되기때문에 버퍼 풀 관리자 같은 것이 필요없어 특정 최적화가 가능하고 성능을  향상시킨다. 이 dbms들은 disk based 보다 확연히 잘나온다.

그런데 이런 in memory 방식은 새로운게 아니라 과거에도 있었다, NewSQL에서 달라진점은 dbms의 하위 집합을 영구저장소로 제거해서 메모리 사용공간을 줄여서 사용가능한 메모리보다 더 큰 데이터베이스를 지원한다.
일반적으로는 시스템 내부 추적 메카니즘을 이용해서 더이상 엑세스 되지 않는지 찾은 후 제거하는 방식이다. 만약 제거된 튜플에 접근을 하려고하면 트랜잭션을 중단하고 별도의 스레드가 비동기적으로 해당 레코드를 찾아서 메모리에 올린다. 
VoltDB에서는 OS 가상 메모리페이징을 이용해서 메모리보다 큰 Database를 지원. 
잘못사용하는것을 방지하기위해 DBMS는 index에 제거된 tuple의 key를 가지고있고 많은 secondary index가 있는 DBMS는 메모리 절약이 잘 되지 않난다.
MEMSQL은 로그 구조화된 스트럭처에 저장. -->

#### 2. 샤딩/파티셔닝

* 대부분의 NewSQL의 Scale out 방법
* 과거에는 하드웨어가 비싸고 tps가 크지 않아 클러스터링을 하지 않았음.
* 하나이상의 칼럼을 기준으로 수평 분할해서 조각들로 나누고 관련한 조각들이 파티션을 이룸.
* DBMS는 여러 파티션에 분산된 데이터 결과를 합칠 수 있음.
* 파티셔닝을 위하 핵심 속성을 가지고 여러테이블들이 파티셔닝됨.
    * 스키마들이 핵싱 특성에 대해 foreign key를 가진 구조
    * ex) 고객이라는 테이블이 루트가 되고 고객을 기준으로 주문기록이나 계정정보와 같은 데이터들이 파티셔닝됨. (게임을 기준으로 생각하면 user table이 루트가 되는식일듯.)
* 일반적으로 각각의 노드가 동일한 기능을  수행하지만 기능이 나뉘어진 NewSQL도 있음.
    * NuoDB
        * 하나이상의 노드가 Storage Manager(SM)이 됨.
        * SM은 실제 파티션 데이터를 가지고 있고 db를 atom이라고하는 단위로 쪼갬.
        * 다른 transaction engine(TE)이라 불리는 나머지 노드들은 atom의 인메모리 케시처럼 사용함.
        * TE가 쿼리를 수행할때 다른 TE나 SM을 통해 필요한 atom을 검색하고 튜플에 대한 락을 잡고 결과를 다른 TE와 SM들로 브로드캐스트함.
        * 데이터가 같은 TE노드에서 사용되게 NuoDB에서 로드벨런싱을 사용함.

    * MemSQL
        * MemSQL도 합치는 aggregator노드랑 실제 데이터를 저장하는 리프노드로 구성.
        * NuoDB와 차이점은 NuoDB는 데이터를 줄이기 위해 TE에 atom을 캐싱해두는데 MemSQL은 캐싱을 사용하지 않고 리프노드에서 쿼리의 일부분을 미리 수행을 한 후 aggregator로 보내는식으로 데이터를 줄임.
* NewSQL의 파티셔닝에서는 실시간 마이그레이션을 지원
    1. 물리적 노드들에 분산된 "가상 파티션"이라는 개념을 사용해서 가상 파티션을 이동하는 방식
    2. range 파티셔닝을 통해서 분배

<!-- 
거의 대부분의 NewSQL이 scale out 방법으로 샤딩과 파티션을 통해 데이터베이스를 나누는 방식이다. 이 아이디어는 새로운 아이디어가 아니지만 당시에는 사용하지 않던 이유가 있다. 먼저 과거에는 클러스터를 꾸리기에는 하드웨어가 비쌌음. 또 과거에는 고성능 분산 DBMS에 대한 요구가 없었음. 당시에 생각되던 tps요구량은 초당 수백건 정도. 지금은 클라우드 컴퓨팅 플랫폼들이 존재하고 오픈 소스 분산시스템이 존재하고 또 저렴한 모바일 디바이스들이 확산해 대규모 데이터 집약적 어플리케이션을 만들기 쉬워졌다.

데이터베이스는 하나이상의 칼럼을 경계로하는 여러조각으로 수평분할을함. DBMS는 range 나 hash를 사용해서 파티션 속성값에 따라 분할을 해서 tuple 을 조각으로 할당한다. (RDBMS랑 같은데?) 여러테이블의 관련된 조각들이 합쳐져서 partition으로 형성되고 단일 노드에 의해 관리된다. 그 단일노드는 해당 파티션에 대해서 쿼리를 수행할 수 있어야한다. 
그리고 이상적으로는 DBMS가 여러파티션에 분산된 데이터 결과를 하나로 합칠 수 있어야한다.(ScaleArc를 제외하고 지원)

OLTP app을 위한 데이터베이스는 파티셔닝을 위한 핵심 특성이 있다. 이러한 데이터베이스에서의 스키마는 루트에 대한 foreign key를 가지고 있는 트리구조로 치환될수있다. 이러한 테이블들은 단일 엔티티에 대한 모든데이터가 하나의 파티션으로 들어간다.
예를 들어 고객테이블이라는 루트가 있고 데이터베이스가 주문기록이나 계정정보등을 포함한 고객별로 나뉜 파티셔닝을 할 수 있다. 이런식으로 나누면 트랜잭션이 단일 파티션에 대해서만 트랜잭션을 해서 투페이즈 커밋과 같은 원자적 트랜잭션 프로토콜 등을 하지 않아도 된다.

NewSQL의 파티셔닝의 특징은 실시간 마이그레이션을 진행한다는것이다. 이를 통해 물리적인 리소스를 서비스를 종료하지 않은상태로 재조정이가능하다. NoSQL의 Rebalancing이랑 비슷한데 ACID까지 지원을해야한다.
이를 위해서 첫번째방법은 가상 파티션에서 데이터 베이스를 구성하는것이다.
다른 방법은 레이지 파티셔닝을 통한 개별 튜플 재분배인다. -->

#### 3. 동시성 컨트롤
동시성 컨트롤은 원자성과 격리를 제공해야하며 시스템의 모든 측면에서 영향을 미치는 부분이다.

* 분산DB에서 동시성 컨트롤은 중앙집권형(Centralized)인지 아니면 분산형(decentralized)인지 두가지로 나뉜다. 
    * 중앙집권형은 코디네이터를 통해서만 트랜잭션이 가능
    * 분산형은 각 노드가 트랜잭션이 충돌하는지 여부를 판단.
        * 분산형은 확장성이 좋지만 고도로 동기화된 클락이 필요

* 과거 DB는 2phase locking을 사용했음.
* NewSQL은 대부분 분산 MVCC를 사용
* 트랜잭션이 업데이트 될떄 새로운 버전의 튜플을 생성
* MVCC +2PL 방식도 존재 수정할때는 락을 잡고 MVCC와 같이 새로운 레코드를 만들고 읽을 때는 락을 잡지않음. 
(오라클 처럼 Undo에 저장하는 방식이  postgreSQL처럼 새로운 로우를 만드는 방식)
* 동시성을 맞추기 위해서 클락들이 싱크가 맞아야하는데 Spanner의 경우 하드웨어(GPS + 원자시계)를 이용해서 싱크를 맞추고 CockRoachDB의 경우 하드웨어 클락과 논리 카운터를 통해 맞춤.
* 동시성 관리의 경우 분산환경에서 동작한다는것을 제외하고는 새로운것은 아님.

<!-- 동시성 컨트롤은 시스템의 모든측면에서 영향을 미치기 때문에 DBMS에서 가장 중요한 부분이다. 최종사용자는 다중 프로그래밍 방식으로 엑세스 할수 있으면서 동시에 각각의 사용자가 혼자 실행하는것처럼 유지할 수 있다.

분산형 DB에서 중요한점은 트랜잭션이 중앙 집권식인지 아니면 분산형인지 이다. 중앙집권식인곳에서는 모든 트랜잭션이 코디네이터를 통해야한다. 분산형에서는 노드가 데이터에 접근하는 트랜잭션 상태를 유지하고 트랜잭션이 충돌하는지 여부를 결정하기위해  조정해야한다. 확장성엔 더 좋지만 고도로 동기화된 클락이 필요하다.

초기에는 2Phase locking 을 사용함.( 트랜잭션이 직접 사용데이터에 락을 검)
NewSQL의 경우 대부분 2phase locking 을 피한다. 대신 트랜잭션이 직렬화 가능 순서를 위반하는 트랜잭션을 하지 않는다라고 DBMS가 가정한는 Timestamp Ordering 기법을 사용함.
가장 많이 사용하는 동시성관리 기법은 decentralized MVCC이다. DBMS가 튜플이 업데이트를 할떄 새로운 버전의 튜플을 생성한다. 멀티 버전을 유지하면 다른 트랜잭션이 다음버전을 업데이트하더라도 트랜잭션을 계속 진행하는것이 가능. 
MVCC + 2PL 방식은 데이터를 수정할때는 락을 잡으나 수정할때 새로운 레코드를 만들고 읽기를 할때는 락을 안잡고 읽음. 
스패너 가 가장최신의 방식인것같은데 MVCC + 2PL을 사용하지만 하드웨어(GPS + 원자시계)를 사용해서 클락 동기화를 맞추는것이 다른점이다.  CockRoach DB도 제공을 하는데 느슨하게 동기화된 하드웨어 클럭과 논리 카운터에 의존한다고함. -->

#### 4. 보조 인덱스

primary key가 아니지만 빠른 속도의 쿼리를 위해 사용하는 인덱스
* 기존 DBMS는 싱글노드여서 primary key를 사용하는것 만큼 효과가 있음
* 분산 DBMS는 여러 노드를 통해 조회해야 할 수 있기때문에 효율이 떨어짐.
* 보조 인덱스를 지원하기 위해서는 두가지 결정 포인트가 있음
    * 1. 저장할 위치
    * 2. 트랜잭션 상태에서 어떻게 관리를 할 것인지
* NewSQL에서는 decentralized 방식으로 각 노드가 인덱스를 저장함
    * 두가지방법이 있는데 1. 각 노드가 인덱스 전체 저장. 2. 각 노드가 일부 저장
        * 장단점
            * 노드가 일부 인덱스를 저장을 하면 쿼리시 여러 노드를 탐색해야할 수 있음
            * 하지만 트랜잭션이 인덱스를 수정한다면 노드를 하나만 수정해도됨. 

<!-- 기존 DBMS에서는 싱글노드를 사용하기에 보조인덱스가 primary key만큼이나 빠른 쿼리에 도움을 주었다. 그런데 분산 dbms에서는 보조 인덱스를 partition과 동일하게  분할시킬 수 없다. 예를들어 DB가 고객테이블의 primary key로 나누어져있는데 고객의 이메일을 역방향으로 조회한다고하면 쿼리를 모든 노드에 뿌려야할 수 있고 이는 비효율적이다.
NewSQL에서는 보조 키를 지원하기 위한 두가지 결정 포인트가 있다. 1) 시스템이 어디다가 저장할것인지 2) 어떻게 이걸 트랜잭션 상태에서 보관할것인지. 중앙집권 코디네이터를 사용하는 방식에서는 보조인덱스가 코디네이터나 샤드 노드에 존재할 수 있음. 인덱스의 단일버전만이 관리된다.

그러나 NewSQL은 모두 decentralized 방식을 사용하고 분할된 보조 인덱스를 사용한다.  각노드가 인덱스의 일부분씩 저장을 한다. 단점의 경우 쿼리가 인덱스를 찾기위해 멀티 노드를 검색해야할 수 있다. 하지만 트랜잭션이 인덱스를 수정한다면 노드를 하나만 업데이트 해도된다.  -->

#### 5. 복제(Replication)

* 복제는 High availability(HA)를 지원하기 좋은 방법
* DBaaS의 경우 관리자가 복제에 대해서 설정을 할 필요가 없기 때문에 이에 강점이 있음.
* 노드간 일관성을 지키는 방법
    * Strongly Consistent replication
        * 커밋이 되기전 트랜잭션이 모든 복제본에 승인되고 반영.
        * 즉 어떠한 트랜잭션이 커밋이 됬다고 결과를 받으면 이후 트랜잭션서는 이 결과가 일관성있게 모든 노드들에서 결과가 반영된것을 보장
        * 한 replica가 실패해도 다른 노드들이 모두 동기화 되기에 사라지는 데이터가 없음
        * 하지만 이를 위해 원자적 트랜잭션을 사용해서 모든 노드의 결과 동의가 필요
        * 오버헤드가 발생될 수 있고 한 노드가 fail되거나 네트워크 문제가 생길 시스템이 중단될 수 있음.
    * Weak consistenct replication(eventual consistency)
        * 커밋시 모든노드들이 트랜잭션을 수정을 승인할 필요가 없음.
        * NoSQL에서 사용
    * NewSQL에서는 Strongly consistent replication을 제공
* 복제 전달 방식
    * active - active replication
        * 각 노드가 동시에  동일한 요청을 동시에 처리함.
        * 트랜잭션이 수행될때 DBMS가 각 replica에서 트랜잭션을 병렬로 수행하도록 함.
        * 네트워크 지연등의 문제로 각 노드의 트랜잭션 순서 보장이 불가능하면 사용 할 수 없음.
    * active - passive replication
        * 한 노드에서 요청을 처리하고 결과를 다른 노드로 전송
        * 대부분의 NewSQL이 아래 방식을 지원 
        * SPanner와 CockroachDB는  비동기 복제 방법을 사용하고 WAN을 통한 복제를 지원함.

<!--             


High availability(HA)를 지원하기 가장 좋은 방법은 복제본을 두는것이다. 최신의 모든 DBMS는 이 방식을 지원한다. DBaaS의 경우 복제에 관해서 고객이 설정이 필요하지 않게 숨김으로서 관리자가 확인할 필요없이 복제된 DBMS를 쉽게 배포.

데이터 복제를 위해서는 두가지 설계 결정이 필요함. 1. 어떻게 노드간의 일관성을 지킬지 .
한가지 방법으로는 커밋전에 트랜잭션이 모든 복제본에 승인되고 반영이 되어야한다. 이러한 방법의 장점으로는 replica가 읽기전용으로 쿼리를 제공할때 일관성이 유지 된다는것이다. 즉 어떤 어플리케이션이 수행한 트랜잭션이 커밋됬다는 결과를 받으면 그 이후 트랜잭션에서는 접근하는 노드와 상관없이 지금 트랜잭션이 결과가 반영되어있다는것을 보장한다. 또한 한 replica가 실패해도 다른 노드들이 동기화 됬으므로 날라가는 데이터가 없다. 
그러나 이를 사용하기 위해서는 모든 노드들이 원자적 트랜잭션을 사용해서 모든 복제본들이 결과에 동의를 해야하고 이는 오버헤드를 발생시키고 노드가 fail되거나 네트워크 문제가 생기면 서비스 중단으로 이루어질 수 있다. 이게 NoSQL이 weak consistency model (eventual consistency) 모델을 선택한 이유이다. (모든 노드들이 수정을 승인할 필요 없는)
NewSQL은 강한 일관성을 제공하고 옛날에 연구된 replication 방식에서 새로운것은 없다. 

일반적으로 많은 NewSQL은 active - passive 를 지원하는데 왜냐면 그들은 비결정론 동시성 제어 체계를 사용하기 때문이다. 왜냐하면 네트워크 지연 (cache stall, clock skew)과 같은 문제로 인해서 각각의 노드에서의 트랜잭션 처리 순서가 달라질 수 있기 때문이다.  -->

#### 장애 복구

* DBMS의 중요한 기능중하나. NewSQL에서는 업데이트가 손실되지 않는게 우선인 기존 DBMS와 다르게 downtime 최소화가 중요 목표.
* 싱글 노드의 경우 DBMS를 다시 실행했을때 로그를 읽어 충돌상태로 되돌린다. (Oracle에서의 redo undo log 사용)
* 분산 DBMS에서는 노드가 죽었을때 다른 노드에서 계속 트랜잭션이 발생해 위방법 사용 불가능
* 1. DB가 다시 복구 된후 로그를 업데이트하고 다른노드로가서 추가적인 로그를 받아 업데이트한다.
* 2. 체크포인트를 삭제하고 새로운 노드의 체크포인트를 받는다. 새 노드가 추가 될때 같은 방법이 사용가능
* 새로운 아키텍처의 NewSQL은 zookeeper, raft와 같은 분산환경관련 기존 요소에 paxos와 같은 기존알고리즘에 대한 구현체를 조합해 사용한다. 

### 미래 트렌드

* transaction과 동시에 해당 데이터를 분석하는 기술이 생길듯
    * 지금은 데이터를 기존 OLTP dbms가 받아들이고 세컨드 백엔드 데이터 웨어하우스로 옮겨서 OLAP 쿼리를 실행하는 방식을 사용중.


<!-- 복제본이 없는 싱글 노드에서의 장애복구는 DBMS를 다시 실행했을때 log를 읽어서 데이터베이스를 충돌상태로 다시 되돌린다.(Oracle에서의 redo undo log사용)
하지만 분산db에서는 마스터가 죽었을때 다른 노드가 마스터가 되서 계속 트랜잭션이 진행되기떄문에 위 방법을 사용할수없음. 복구노드는 다른노드에 가서 정보를 받아야함.
방법1) db가 다시 뜬후 log를 로드한후 다른 노드의 로그를 가져와서 업데이트한다.
위방법은 db가 physical log를 사용하는경우 사용가능함. 
방법2) db가 체크포인트를 삭제하고 새로운 노드의 체크포인트를 받는다. 장점은 새 노드가 들어올때 같은 방법을 적용가능하다. 
새로운 아키텍처로 만든 NewSQL은 zookeeper raft와 같은 기존 요소에 기존알고리즘(ex paxos)을 구현한것을 조합해 사용한다. -->

### 결론

NewSQL은 갑자기 튀어나온 새로운 구조가 아니라 예전부터 존재하던 기술들로 구현된것이다. 
이러한 기술들은 단일 DBMS에서 사용된적이 있지만 함께 구현되지 않았었고 NewSQL은 단일 플랫폼에 이러한 기술들을 다 합쳐서 구현했다는것이 특징이다. 단순히 엔지니어링의 노력이 추가가 된것이아니라 분산 컴퓨팅 리소스가 저렴해지고 어플리케이션의 요구량이 많아진 시대의 흐름이다. 
<!-- 하지만 NewSQL은 엔터프라이즈 워크로드에 대해 지원하도록 설계되어있어서 새로운 어플리케이션에 NoSQL이 쉽게 사용되는것과 달리 보수적인 환경이라 잘 사용되고 있지않음.
또한 기존 DBMS공급업체들도 자체 시스템을 개선하고있음. 지금 위의 언급한것처럼 1) 과거 DBMS 2)OLAP 데이터웨어하우스 3) NoSQL 4) NewSQL로 분류하였지만 이후 모든 형태들이 관계형모델, SQL, OLTP, OLAP 등을 전부 제공하는 날이오면 분류가 의미 없어질것이라 생각함. -->